{"ast":null,"code":"'use strict';\n\nconst inflect = require('i')();\nlet __id__ = 0;\nclass RelationshipPath {\n  constructor(path) {\n    this.path = path;\n  }\n  toString() {\n    return this.path.join(' <-> ');\n  }\n  joinName(reverse) {\n    let path = [].slice.call(this.path);\n    if (reverse) {\n      path = path.reverse();\n    }\n    let names = [];\n    while (path.length > 1) {\n      let node = path.pop();\n      let edge = path.pop();\n      names.push(edge.hasChild(node) ? edge.options.name : edge.options.as);\n    }\n    return names.join('__');\n  }\n  add(node, edge) {\n    return new this.constructor([node, edge].concat(this.path));\n  }\n  getModel() {\n    return this.path[0].Model;\n  }\n  multiple() {\n    for (let i = 1; i < this.path.length; i += 2) {\n      let edge = this.path[i];\n      let node = this.path[i - 1];\n      if (edge.hasChild(node) && edge.options.multiple) {\n        return true;\n      }\n    }\n    return false;\n  }\n  immediateMultiple() {\n    let node = this.path[0];\n    let edge = this.path[1];\n    if (edge.hasChild(node) && edge.options.multiple) {\n      return true;\n    }\n    return false;\n  }\n  joins(alias, firstTable) {\n    let node;\n    let i = 0;\n    return this.path.slice().reverse().reduce((joins, item) => {\n      if (item instanceof RelationshipNode) {\n        node = item;\n        return joins;\n      }\n      let edge = item;\n      let join = {\n        joinTable: edge.opposite(node).Model.table(),\n        prevTable: joins[joins.length - 1] ? joins[joins.length - 1].joinAlias : firstTable || null\n      };\n      if (edge.hasChild(node)) {\n        join.prevColumn = edge.options.via;\n        join.joinColumn = edge.options.using;\n        join.joinAlias = edge.options.name;\n      } else {\n        join.prevColumn = edge.options.using;\n        join.joinColumn = edge.options.via;\n        join.joinAlias = edge.options.as;\n      }\n      join.joinAlias = alias ? `${alias}${++i}` : join.joinAlias;\n      joins.push(join);\n      return joins;\n    }, []);\n  }\n}\nclass RelationshipNode {\n  constructor(Graph, Model) {\n    this.Graph = Graph;\n    this.Model = Model;\n    this.edges = [];\n  }\n  toString() {\n    return `[Node: ${this.Model.name}]`;\n  }\n  joinsTo(Model, options) {\n    if (!Model.name) {\n      // Sanity check for circular dependency resolution\n      return null;\n    }\n    options = options || {};\n    options.multiple = !!options.multiple;\n    options.as = options.as || (options.multiple ? `${inflect.pluralize(inflect.camelize(this.Model.name, false))}` : `${inflect.camelize(this.Model.name, false)}`);\n    options.name = options.name || `${inflect.camelize(Model.name, false)}`;\n    options.via = options.via || `${inflect.underscore(options.name)}_id`;\n    options.using = options.using || `id`;\n    let parentNode = this.Graph.of(Model);\n    let edge = this.edges.filter(e => e.parent === parentNode && e.options.name === options.name).pop();\n    if (!edge) {\n      edge = new RelationshipEdge(parentNode, this, options);\n    }\n    return edge;\n  }\n  childEdges() {\n    return this.edges.filter(edge => edge.parent === this);\n  }\n  cascade() {\n    let queue = this.childEdges();\n    let paths = queue.map(e => new RelationshipPath([e.child, e, e.parent]));\n    let i = 0;\n    while (queue.length) {\n      let edge = queue.shift();\n      let curPath = paths[i++];\n      let nextEdges = edge.child.childEdges();\n      queue = queue.concat(nextEdges);\n      paths = paths.concat(nextEdges.map(e => curPath.add(e.child, e)));\n    }\n    return paths;\n  }\n  findExplicit(pathname) {\n    let names = pathname.split('__');\n    let node = this;\n    let path = new RelationshipPath([node]);\n    while (names.length) {\n      let name = names.shift();\n      let edges = node.edges.filter(edge => {\n        return edge.hasChild(node) && edge.options.name === name || edge.options.as === name;\n      });\n      if (edges.length === 0) {\n        return null;\n      }\n      let edge = edges.pop();\n      let nextNode = edge.opposite(node);\n      path = path.add(nextNode, edge);\n      node = nextNode;\n    }\n    return path;\n  }\n  find(name) {\n    let queue = this.edges.slice().map(edge => {\n      return {\n        edge: edge,\n        path: new RelationshipPath([this])\n      };\n    });\n    let traversed = {};\n    while (queue.length) {\n      let item = queue[0];\n      let curEdge = item.edge;\n      let path = item.path;\n      let node;\n      traversed[curEdge.id] = true;\n      let curNode = path.path[0];\n      node = curEdge.opposite(curNode);\n      if (curEdge.hasChild(curNode) && curEdge.options.name === name || curEdge.options.as === name) {\n        return path.add(node, curEdge);\n      }\n      queue = queue.slice(1).concat(node.edges.filter(edge => !traversed[edge.id]).map(edge => {\n        return {\n          edge: edge,\n          path: path.add(node, curEdge)\n        };\n      }));\n    }\n    return null;\n  }\n}\nclass RelationshipEdge {\n  constructor(parent, child, options) {\n    this.id = ++__id__;\n    this.parent = parent;\n    this.child = child;\n    this.options = options;\n    parent.edges.push(this);\n    child.edges.push(this);\n  }\n  toString() {\n    return `[Edge: ${this.parent.Model.name}, ${this.child.Model.name}]`;\n  }\n  hasChild(child) {\n    return this.child === child;\n  }\n  hasParent(parent) {\n    return this.parent === parent;\n  }\n  opposite(node) {\n    let opposite = this.child === node ? this.parent : this.parent === node ? this.child : null;\n    return opposite;\n  }\n}\nclass RelationshipGraph {\n  constructor() {\n    this.nodes = [];\n    this.edges = [];\n  }\n  of(Model) {\n    let node = this.nodes.filter(n => n.Model === Model).pop();\n    if (!node) {\n      node = new RelationshipNode(this, Model);\n      this.nodes.push(node);\n    }\n    return node;\n  }\n}\nmodule.exports = RelationshipGraph;","map":{"version":3,"names":["inflect","require","__id__","RelationshipPath","constructor","path","toString","join","joinName","reverse","slice","call","names","length","node","pop","edge","push","hasChild","options","name","as","add","concat","getModel","Model","multiple","i","immediateMultiple","joins","alias","firstTable","reduce","item","RelationshipNode","joinTable","opposite","table","prevTable","joinAlias","prevColumn","via","joinColumn","using","Graph","edges","joinsTo","pluralize","camelize","underscore","parentNode","of","filter","e","parent","RelationshipEdge","childEdges","cascade","queue","paths","map","child","shift","curPath","nextEdges","findExplicit","pathname","split","nextNode","find","traversed","curEdge","id","curNode","hasParent","RelationshipGraph","nodes","n","module","exports"],"sources":["/Users/apps/node_modules/carthage/core/required/relationship_graph.js"],"sourcesContent":["'use strict';\n\nconst inflect = require('i')();\nlet __id__ = 0;\n\nclass RelationshipPath {\n\n  constructor(path) {\n    this.path = path;\n  }\n\n  toString() {\n    return this.path.join(' <-> ');\n  }\n\n  joinName(reverse) {\n\n    let path = [].slice.call(this.path);\n\n    if (reverse) {\n      path = path.reverse();\n    }\n\n    let names = [];\n\n    while (path.length > 1) {\n      let node = path.pop();\n      let edge = path.pop();\n      names.push(edge.hasChild(node) ? edge.options.name : edge.options.as);\n    }\n\n    return names.join('__');\n\n  }\n\n  add(node, edge) {\n    return new this.constructor([node, edge].concat(this.path));\n  }\n\n  getModel() {\n    return this.path[0].Model;\n  }\n\n  multiple() {\n    for (let i = 1; i < this.path.length; i += 2) {\n      let edge = this.path[i];\n      let node = this.path[i - 1];\n      if (edge.hasChild(node) && edge.options.multiple) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  immediateMultiple() {\n    let node = this.path[0];\n    let edge = this.path[1];\n    if (edge.hasChild(node) && edge.options.multiple) {\n      return true;\n    }\n    return false;\n  }\n\n  joins(alias, firstTable) {\n\n    let node;\n    let i = 0;\n    return this.path.slice().reverse().reduce((joins, item) => {\n\n      if (item instanceof RelationshipNode) {\n        node = item;\n        return joins;\n      }\n\n      let edge = item;\n\n      let join = {\n        joinTable: edge.opposite(node).Model.table(),\n        prevTable: joins[joins.length - 1] ? joins[joins.length - 1].joinAlias : (firstTable || null),\n      };\n\n      if (edge.hasChild(node)) {\n        join.prevColumn = edge.options.via;\n        join.joinColumn = edge.options.using;\n        join.joinAlias = edge.options.name;\n      } else {\n        join.prevColumn = edge.options.using;\n        join.joinColumn = edge.options.via;\n        join.joinAlias = edge.options.as;\n      }\n\n      join.joinAlias = alias ? `${alias}${++i}` : join.joinAlias;\n\n      joins.push(join);\n\n      return joins;\n\n    }, []);\n\n  }\n\n}\n\nclass RelationshipNode {\n\n  constructor(Graph, Model) {\n    this.Graph = Graph;\n    this.Model = Model;\n    this.edges = [];\n  }\n\n  toString() {\n    return `[Node: ${this.Model.name}]`;\n  }\n\n  joinsTo(Model, options) {\n\n    if (!Model.name) {\n      // Sanity check for circular dependency resolution\n      return null;\n    }\n\n    options = options || {};\n\n    options.multiple = !!options.multiple;\n    options.as = options.as || (options.multiple ? `${inflect.pluralize(inflect.camelize(this.Model.name, false))}` : `${inflect.camelize(this.Model.name, false)}`);\n    options.name = options.name || `${inflect.camelize(Model.name, false)}`;\n    options.via = options.via || `${inflect.underscore(options.name)}_id`;\n    options.using = options.using || `id`;\n\n    let parentNode = this.Graph.of(Model);\n    let edge = this.edges.filter(e => e.parent === parentNode && e.options.name === options.name).pop();\n\n    if (!edge) {\n      edge = new RelationshipEdge(parentNode, this, options);\n    }\n\n    return edge;\n\n  }\n\n  childEdges() {\n    return this.edges.filter(edge => edge.parent === this);\n  }\n\n  cascade() {\n\n    let queue = this.childEdges();\n    let paths = queue.map(e => new RelationshipPath([e.child, e, e.parent]));\n\n    let i = 0;\n    while (queue.length) {\n\n      let edge = queue.shift();\n      let curPath = paths[i++];\n\n      let nextEdges = edge.child.childEdges();\n      queue = queue.concat(nextEdges);\n\n      paths = paths.concat(nextEdges.map(e => curPath.add(e.child, e)));\n\n    }\n\n    return paths;\n\n  }\n\n  findExplicit(pathname) {\n\n    let names = pathname.split('__');\n    let node = this;\n    let path = new RelationshipPath([node]);\n\n\n    while (names.length) {\n\n      let name = names.shift();\n\n      let edges = node.edges.filter(edge => {\n        return (edge.hasChild(node) && edge.options.name === name) || edge.options.as === name;\n      });\n\n      if (edges.length === 0) {\n        return null;\n      }\n\n      let edge = edges.pop();\n      let nextNode = edge.opposite(node);\n\n      path = path.add(nextNode, edge);\n      node = nextNode;\n\n    }\n\n    return path;\n\n  }\n\n  find(name) {\n\n    let queue = this.edges\n      .slice()\n      .map(edge => {\n        return {edge: edge, path: new RelationshipPath([this])}\n      });\n\n    let traversed = {};\n\n    while (queue.length) {\n\n      let item = queue[0];\n      let curEdge = item.edge;\n      let path = item.path;\n      let node;\n\n      traversed[curEdge.id] = true;\n\n      let curNode = path.path[0];\n      node = curEdge.opposite(curNode);\n\n      if ((curEdge.hasChild(curNode) && curEdge.options.name === name) || curEdge.options.as === name) {\n        return path.add(node, curEdge);\n      }\n\n      queue = queue.slice(1).concat(\n        node.edges\n          .filter(edge => !traversed[edge.id])\n          .map(edge => {\n            return {\n              edge: edge,\n              path: path.add(node, curEdge)\n            };\n          })\n      );\n\n    }\n\n    return null;\n\n  }\n\n}\n\nclass RelationshipEdge {\n\n  constructor(parent, child, options) {\n\n    this.id = ++__id__;\n    this.parent = parent;\n    this.child = child;\n    this.options = options;\n\n    parent.edges.push(this);\n    child.edges.push(this);\n\n  }\n\n  toString() {\n    return `[Edge: ${this.parent.Model.name}, ${this.child.Model.name}]`;\n  }\n\n  hasChild(child) {\n    return this.child === child;\n  }\n\n  hasParent(parent) {\n    return this.parent === parent;\n  }\n\n  opposite(node) {\n    let opposite = this.child === node ? this.parent : (this.parent === node ? this.child : null);\n    return opposite;\n  }\n\n}\n\nclass RelationshipGraph {\n\n  constructor() {\n    this.nodes = [];\n    this.edges = [];\n  }\n\n  of(Model) {\n\n    let node = this.nodes.filter(n => n.Model === Model).pop();\n    if (!node) {\n      node = new RelationshipNode(this, Model);\n      this.nodes.push(node);\n    }\n\n    return node;\n\n  }\n\n}\n\nmodule.exports = RelationshipGraph;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}