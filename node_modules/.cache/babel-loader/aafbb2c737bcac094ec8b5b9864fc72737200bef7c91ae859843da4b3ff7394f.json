{"ast":null,"code":"// A singleton instance of this class is yielded by Inflector.inflections, which can then be used to specify additional\n// inflection rules. Examples:\n//\n//     BulletSupport.Inflector.inflect ($) ->\n//       $.plural /^(ox)$/i, '$1en'\n//       $.singular /^(ox)en/i, '$1'\n//\n//       $.irregular 'octopus', 'octopi'\n//\n//       $.uncountable \"equipment\"\n//\n// New rules are added at the top. So in the example above, the irregular rule for octopus will now be the first of the\n// pluralization and singularization rules that is runs. This guarantees that your rules run before any of the rules that may\n// already have been loaded.\n\nvar util = require('./util');\nvar Inflections = function () {\n  this.plurals = [];\n  this.singulars = [];\n  this.uncountables = [];\n  this.humans = [];\n  require('./defaults')(this);\n  return this;\n};\n\n// Specifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression.\n// The replacement should always be a string that may include references to the matched data from the rule.\nInflections.prototype.plural = function (rule, replacement) {\n  if (typeof rule == 'string') {\n    this.uncountables = util.array.del(this.uncountables, rule);\n  }\n  this.uncountables = util.array.del(this.uncountables, replacement);\n  this.plurals.unshift([rule, replacement]);\n};\n\n// Specifies a new singularization rule and its replacement. The rule can either be a string or a regular expression.\n// The replacement should always be a string that may include references to the matched data from the rule.\nInflections.prototype.singular = function (rule, replacement) {\n  if (typeof rule == 'string') {\n    this.uncountables = util.array.del(this.uncountables, rule);\n  }\n  this.uncountables = util.array.del(this.uncountables, replacement);\n  this.singulars.unshift([rule, replacement]);\n};\n\n// Specifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used\n// for strings, not regular expressions. You simply pass the irregular in singular and plural form.\n//\n//     irregular 'octopus', 'octopi'\n//     irregular 'person', 'people'\nInflections.prototype.irregular = function (singular, plural, fullMatchRequired) {\n  this.uncountables = util.array.del(this.uncountables, singular);\n  this.uncountables = util.array.del(this.uncountables, plural);\n  var prefix = '';\n  if (fullMatchRequired) {\n    prefix = '^';\n  }\n  if (singular[0].toUpperCase() == plural[0].toUpperCase()) {\n    this.plural(new RegExp('(' + prefix + singular[0] + ')' + singular.slice(1) + '$', 'i'), '$1' + plural.slice(1));\n    this.plural(new RegExp('(' + prefix + plural[0] + ')' + plural.slice(1) + '$', 'i'), '$1' + plural.slice(1));\n    this.singular(new RegExp('(' + prefix + plural[0] + ')' + plural.slice(1) + '$', 'i'), '$1' + singular.slice(1));\n  } else {\n    this.plural(new RegExp(prefix + singular[0].toUpperCase() + singular.slice(1) + '$'), plural[0].toUpperCase() + plural.slice(1));\n    this.plural(new RegExp(prefix + singular[0].toLowerCase() + singular.slice(1) + '$'), plural[0].toLowerCase() + plural.slice(1));\n    this.plural(new RegExp(prefix + plural[0].toUpperCase() + plural.slice(1) + '$'), plural[0].toUpperCase() + plural.slice(1));\n    this.plural(new RegExp(prefix + plural[0].toLowerCase() + plural.slice(1) + '$'), plural[0].toLowerCase() + plural.slice(1));\n    this.singular(new RegExp(prefix + plural[0].toUpperCase() + plural.slice(1) + '$'), singular[0].toUpperCase() + singular.slice(1));\n    this.singular(new RegExp(prefix + plural[0].toLowerCase() + plural.slice(1) + '$'), singular[0].toLowerCase() + singular.slice(1));\n  }\n};\n\n// Specifies a humanized form of a string by a regular expression rule or by a string mapping.\n// When using a regular expression based replacement, the normal humanize formatting is called after the replacement.\n// When a string is used, the human form should be specified as desired (example: 'The name', not 'the_name')\n//\n//     human /(.*)_cnt$/i, '$1_count'\n//     human \"legacy_col_person_name\", \"Name\"\nInflections.prototype.human = function (rule, replacement) {\n  this.humans.unshift([rule, replacement]);\n};\n\n// Add uncountable words that shouldn't be attempted inflected.\n//\n//     uncountable \"money\"\n//     uncountable [\"money\", \"information\"]\nInflections.prototype.uncountable = function (words) {\n  this.uncountables = this.uncountables.concat(words);\n};\n\n// Clears the loaded inflections within a given scope (default is _'all'_).\n// Give the scope as a symbol of the inflection type, the options are: _'plurals'_,\n// _'singulars'_, _'uncountables'_, _'humans'_.\n//\n//     clear 'all'\n//     clear 'plurals'\nInflections.prototype.clear = function (scope) {\n  if (scope == null) scope = 'all';\n  switch (scope) {\n    case 'all':\n      this.plurals = [];\n      this.singulars = [];\n      this.uncountables = [];\n      this.humans = [];\n    default:\n      this[scope] = [];\n  }\n};\n\n// Clears the loaded inflections and initializes them to [default](../inflections.html)\nInflections.prototype.default = function () {\n  this.plurals = [];\n  this.singulars = [];\n  this.uncountables = [];\n  this.humans = [];\n  require('./defaults')(this);\n  return this;\n};\nmodule.exports = new Inflections();","map":{"version":3,"names":["util","require","Inflections","plurals","singulars","uncountables","humans","prototype","plural","rule","replacement","array","del","unshift","singular","irregular","fullMatchRequired","prefix","toUpperCase","RegExp","slice","toLowerCase","human","uncountable","words","concat","clear","scope","default","module","exports"],"sources":["/Users/apps/node_modules/i/lib/inflections.js"],"sourcesContent":["// A singleton instance of this class is yielded by Inflector.inflections, which can then be used to specify additional\n// inflection rules. Examples:\n//\n//     BulletSupport.Inflector.inflect ($) ->\n//       $.plural /^(ox)$/i, '$1en'\n//       $.singular /^(ox)en/i, '$1'\n//\n//       $.irregular 'octopus', 'octopi'\n//\n//       $.uncountable \"equipment\"\n//\n// New rules are added at the top. So in the example above, the irregular rule for octopus will now be the first of the\n// pluralization and singularization rules that is runs. This guarantees that your rules run before any of the rules that may\n// already have been loaded.\n\nvar util = require('./util');\n\nvar Inflections = function () {\n  this.plurals = [];\n  this.singulars = [];\n  this.uncountables = [];\n  this.humans = [];\n  require('./defaults')(this);\n  return this;\n};\n\n// Specifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression.\n// The replacement should always be a string that may include references to the matched data from the rule.\nInflections.prototype.plural = function (rule, replacement) {\n  if (typeof rule == 'string') {\n    this.uncountables = util.array.del(this.uncountables, rule);\n  }\n  this.uncountables = util.array.del(this.uncountables, replacement);\n  this.plurals.unshift([rule, replacement]);\n};\n\n// Specifies a new singularization rule and its replacement. The rule can either be a string or a regular expression.\n// The replacement should always be a string that may include references to the matched data from the rule.\nInflections.prototype.singular = function (rule, replacement) {\n  if (typeof rule == 'string') {\n    this.uncountables = util.array.del(this.uncountables, rule);\n  }\n  this.uncountables = util.array.del(this.uncountables, replacement);\n  this.singulars.unshift([rule, replacement]);\n};\n\n// Specifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used\n// for strings, not regular expressions. You simply pass the irregular in singular and plural form.\n//\n//     irregular 'octopus', 'octopi'\n//     irregular 'person', 'people'\nInflections.prototype.irregular = function (singular, plural, fullMatchRequired) {\n  this.uncountables = util.array.del(this.uncountables, singular);\n  this.uncountables = util.array.del(this.uncountables, plural);\n  var prefix = '';\n  if (fullMatchRequired) {\n    prefix = '^';\n  }\n  if (singular[0].toUpperCase() == plural[0].toUpperCase()) {\n    this.plural(new RegExp('(' + prefix + singular[0] + ')' + singular.slice(1) + '$', 'i'), '$1' + plural.slice(1));\n    this.plural(new RegExp('(' + prefix + plural[0] + ')' + plural.slice(1) + '$', 'i'), '$1' + plural.slice(1));\n    this.singular(new RegExp('(' + prefix + plural[0] + ')' + plural.slice(1) + '$', 'i'), '$1' + singular.slice(1));\n  } else {\n    this.plural(\n      new RegExp(prefix + singular[0].toUpperCase() + singular.slice(1) + '$'),\n      plural[0].toUpperCase() + plural.slice(1)\n    );\n    this.plural(\n      new RegExp(prefix + singular[0].toLowerCase() + singular.slice(1) + '$'),\n      plural[0].toLowerCase() + plural.slice(1)\n    );\n    this.plural(\n      new RegExp(prefix + plural[0].toUpperCase() + plural.slice(1) + '$'),\n      plural[0].toUpperCase() + plural.slice(1)\n    );\n    this.plural(\n      new RegExp(prefix + plural[0].toLowerCase() + plural.slice(1) + '$'),\n      plural[0].toLowerCase() + plural.slice(1)\n    );\n    this.singular(\n      new RegExp(prefix + plural[0].toUpperCase() + plural.slice(1) + '$'),\n      singular[0].toUpperCase() + singular.slice(1)\n    );\n    this.singular(\n      new RegExp(prefix + plural[0].toLowerCase() + plural.slice(1) + '$'),\n      singular[0].toLowerCase() + singular.slice(1)\n    );\n  }\n};\n\n// Specifies a humanized form of a string by a regular expression rule or by a string mapping.\n// When using a regular expression based replacement, the normal humanize formatting is called after the replacement.\n// When a string is used, the human form should be specified as desired (example: 'The name', not 'the_name')\n//\n//     human /(.*)_cnt$/i, '$1_count'\n//     human \"legacy_col_person_name\", \"Name\"\nInflections.prototype.human = function (rule, replacement) {\n  this.humans.unshift([rule, replacement]);\n};\n\n// Add uncountable words that shouldn't be attempted inflected.\n//\n//     uncountable \"money\"\n//     uncountable [\"money\", \"information\"]\nInflections.prototype.uncountable = function (words) {\n  this.uncountables = this.uncountables.concat(words);\n};\n\n// Clears the loaded inflections within a given scope (default is _'all'_).\n// Give the scope as a symbol of the inflection type, the options are: _'plurals'_,\n// _'singulars'_, _'uncountables'_, _'humans'_.\n//\n//     clear 'all'\n//     clear 'plurals'\nInflections.prototype.clear = function (scope) {\n  if (scope == null) scope = 'all';\n  switch (scope) {\n    case 'all':\n      this.plurals = [];\n      this.singulars = [];\n      this.uncountables = [];\n      this.humans = [];\n    default:\n      this[scope] = [];\n  }\n};\n\n// Clears the loaded inflections and initializes them to [default](../inflections.html)\nInflections.prototype.default = function () {\n  this.plurals = [];\n  this.singulars = [];\n  this.uncountables = [];\n  this.humans = [];\n  require('./defaults')(this);\n  return this;\n};\n\nmodule.exports = new Inflections();\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAE5B,IAAIC,WAAW,GAAG,SAAAA,CAAA,EAAY;EAC5B,IAAI,CAACC,OAAO,GAAG,EAAE;EACjB,IAAI,CAACC,SAAS,GAAG,EAAE;EACnB,IAAI,CAACC,YAAY,GAAG,EAAE;EACtB,IAAI,CAACC,MAAM,GAAG,EAAE;EAChBL,OAAO,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC;EAC3B,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACAC,WAAW,CAACK,SAAS,CAACC,MAAM,GAAG,UAAUC,IAAI,EAAEC,WAAW,EAAE;EAC1D,IAAI,OAAOD,IAAI,IAAI,QAAQ,EAAE;IAC3B,IAAI,CAACJ,YAAY,GAAGL,IAAI,CAACW,KAAK,CAACC,GAAG,CAAC,IAAI,CAACP,YAAY,EAAEI,IAAI,CAAC;EAC7D;EACA,IAAI,CAACJ,YAAY,GAAGL,IAAI,CAACW,KAAK,CAACC,GAAG,CAAC,IAAI,CAACP,YAAY,EAAEK,WAAW,CAAC;EAClE,IAAI,CAACP,OAAO,CAACU,OAAO,CAAC,CAACJ,IAAI,EAAEC,WAAW,CAAC,CAAC;AAC3C,CAAC;;AAED;AACA;AACAR,WAAW,CAACK,SAAS,CAACO,QAAQ,GAAG,UAAUL,IAAI,EAAEC,WAAW,EAAE;EAC5D,IAAI,OAAOD,IAAI,IAAI,QAAQ,EAAE;IAC3B,IAAI,CAACJ,YAAY,GAAGL,IAAI,CAACW,KAAK,CAACC,GAAG,CAAC,IAAI,CAACP,YAAY,EAAEI,IAAI,CAAC;EAC7D;EACA,IAAI,CAACJ,YAAY,GAAGL,IAAI,CAACW,KAAK,CAACC,GAAG,CAAC,IAAI,CAACP,YAAY,EAAEK,WAAW,CAAC;EAClE,IAAI,CAACN,SAAS,CAACS,OAAO,CAAC,CAACJ,IAAI,EAAEC,WAAW,CAAC,CAAC;AAC7C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAR,WAAW,CAACK,SAAS,CAACQ,SAAS,GAAG,UAAUD,QAAQ,EAAEN,MAAM,EAAEQ,iBAAiB,EAAE;EAC/E,IAAI,CAACX,YAAY,GAAGL,IAAI,CAACW,KAAK,CAACC,GAAG,CAAC,IAAI,CAACP,YAAY,EAAES,QAAQ,CAAC;EAC/D,IAAI,CAACT,YAAY,GAAGL,IAAI,CAACW,KAAK,CAACC,GAAG,CAAC,IAAI,CAACP,YAAY,EAAEG,MAAM,CAAC;EAC7D,IAAIS,MAAM,GAAG,EAAE;EACf,IAAID,iBAAiB,EAAE;IACrBC,MAAM,GAAG,GAAG;EACd;EACA,IAAIH,QAAQ,CAAC,CAAC,CAAC,CAACI,WAAW,CAAC,CAAC,IAAIV,MAAM,CAAC,CAAC,CAAC,CAACU,WAAW,CAAC,CAAC,EAAE;IACxD,IAAI,CAACV,MAAM,CAAC,IAAIW,MAAM,CAAC,GAAG,GAAGF,MAAM,GAAGH,QAAQ,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGA,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,EAAE,GAAG,CAAC,EAAE,IAAI,GAAGZ,MAAM,CAACY,KAAK,CAAC,CAAC,CAAC,CAAC;IAChH,IAAI,CAACZ,MAAM,CAAC,IAAIW,MAAM,CAAC,GAAG,GAAGF,MAAM,GAAGT,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGA,MAAM,CAACY,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,EAAE,GAAG,CAAC,EAAE,IAAI,GAAGZ,MAAM,CAACY,KAAK,CAAC,CAAC,CAAC,CAAC;IAC5G,IAAI,CAACN,QAAQ,CAAC,IAAIK,MAAM,CAAC,GAAG,GAAGF,MAAM,GAAGT,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGA,MAAM,CAACY,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,EAAE,GAAG,CAAC,EAAE,IAAI,GAAGN,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC;EAClH,CAAC,MAAM;IACL,IAAI,CAACZ,MAAM,CACT,IAAIW,MAAM,CAACF,MAAM,GAAGH,QAAQ,CAAC,CAAC,CAAC,CAACI,WAAW,CAAC,CAAC,GAAGJ,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EACxEZ,MAAM,CAAC,CAAC,CAAC,CAACU,WAAW,CAAC,CAAC,GAAGV,MAAM,CAACY,KAAK,CAAC,CAAC,CAC1C,CAAC;IACD,IAAI,CAACZ,MAAM,CACT,IAAIW,MAAM,CAACF,MAAM,GAAGH,QAAQ,CAAC,CAAC,CAAC,CAACO,WAAW,CAAC,CAAC,GAAGP,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EACxEZ,MAAM,CAAC,CAAC,CAAC,CAACa,WAAW,CAAC,CAAC,GAAGb,MAAM,CAACY,KAAK,CAAC,CAAC,CAC1C,CAAC;IACD,IAAI,CAACZ,MAAM,CACT,IAAIW,MAAM,CAACF,MAAM,GAAGT,MAAM,CAAC,CAAC,CAAC,CAACU,WAAW,CAAC,CAAC,GAAGV,MAAM,CAACY,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EACpEZ,MAAM,CAAC,CAAC,CAAC,CAACU,WAAW,CAAC,CAAC,GAAGV,MAAM,CAACY,KAAK,CAAC,CAAC,CAC1C,CAAC;IACD,IAAI,CAACZ,MAAM,CACT,IAAIW,MAAM,CAACF,MAAM,GAAGT,MAAM,CAAC,CAAC,CAAC,CAACa,WAAW,CAAC,CAAC,GAAGb,MAAM,CAACY,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EACpEZ,MAAM,CAAC,CAAC,CAAC,CAACa,WAAW,CAAC,CAAC,GAAGb,MAAM,CAACY,KAAK,CAAC,CAAC,CAC1C,CAAC;IACD,IAAI,CAACN,QAAQ,CACX,IAAIK,MAAM,CAACF,MAAM,GAAGT,MAAM,CAAC,CAAC,CAAC,CAACU,WAAW,CAAC,CAAC,GAAGV,MAAM,CAACY,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EACpEN,QAAQ,CAAC,CAAC,CAAC,CAACI,WAAW,CAAC,CAAC,GAAGJ,QAAQ,CAACM,KAAK,CAAC,CAAC,CAC9C,CAAC;IACD,IAAI,CAACN,QAAQ,CACX,IAAIK,MAAM,CAACF,MAAM,GAAGT,MAAM,CAAC,CAAC,CAAC,CAACa,WAAW,CAAC,CAAC,GAAGb,MAAM,CAACY,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EACpEN,QAAQ,CAAC,CAAC,CAAC,CAACO,WAAW,CAAC,CAAC,GAAGP,QAAQ,CAACM,KAAK,CAAC,CAAC,CAC9C,CAAC;EACH;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAlB,WAAW,CAACK,SAAS,CAACe,KAAK,GAAG,UAAUb,IAAI,EAAEC,WAAW,EAAE;EACzD,IAAI,CAACJ,MAAM,CAACO,OAAO,CAAC,CAACJ,IAAI,EAAEC,WAAW,CAAC,CAAC;AAC1C,CAAC;;AAED;AACA;AACA;AACA;AACAR,WAAW,CAACK,SAAS,CAACgB,WAAW,GAAG,UAAUC,KAAK,EAAE;EACnD,IAAI,CAACnB,YAAY,GAAG,IAAI,CAACA,YAAY,CAACoB,MAAM,CAACD,KAAK,CAAC;AACrD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAtB,WAAW,CAACK,SAAS,CAACmB,KAAK,GAAG,UAAUC,KAAK,EAAE;EAC7C,IAAIA,KAAK,IAAI,IAAI,EAAEA,KAAK,GAAG,KAAK;EAChC,QAAQA,KAAK;IACX,KAAK,KAAK;MACR,IAAI,CAACxB,OAAO,GAAG,EAAE;MACjB,IAAI,CAACC,SAAS,GAAG,EAAE;MACnB,IAAI,CAACC,YAAY,GAAG,EAAE;MACtB,IAAI,CAACC,MAAM,GAAG,EAAE;IAClB;MACE,IAAI,CAACqB,KAAK,CAAC,GAAG,EAAE;EACpB;AACF,CAAC;;AAED;AACAzB,WAAW,CAACK,SAAS,CAACqB,OAAO,GAAG,YAAY;EAC1C,IAAI,CAACzB,OAAO,GAAG,EAAE;EACjB,IAAI,CAACC,SAAS,GAAG,EAAE;EACnB,IAAI,CAACC,YAAY,GAAG,EAAE;EACtB,IAAI,CAACC,MAAM,GAAG,EAAE;EAChBL,OAAO,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC;EAC3B,OAAO,IAAI;AACb,CAAC;AAED4B,MAAM,CAACC,OAAO,GAAG,IAAI5B,WAAW,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}