{"ast":null,"code":"'use strict';\n\nconst ItemArray = require('./item_array.js');\nconst ModelArray = require('./model_array.js');\nconst utilities = require('./utilities.js');\n\n/**\n* The query composer (ORM)\n* @class\n*/\nclass Composer {\n  /**\n  * Created by Model#query, used for composing SQL queries based on Models\n  * @param {Carthage.Model} Model The model class the composer is querying from\n  * @param {Carthage.Composer} [parent=null] The composer's parent (another composer instance)\n  */\n  constructor(Model, parent) {\n    this.db = Model.prototype.db;\n    this.Model = Model;\n    this._parent = parent || null;\n    this._command = null;\n  }\n\n  /**\n  * Given rows with repeated data (due to joining in multiple children), return only parent models (but include references to their children)\n  * @param {Array} rows Rows from sql result\n  * @param {Boolean} grouped Are these models grouped, if so, different procedure\n  * @return {Carthage.ModelArray}\n  * @private\n  */\n  __parseModelsFromRows__(rows, grouped) {\n    if (grouped) {\n      return ItemArray.from(rows);\n    }\n    if (!rows.length) {\n      return new ModelArray(this.Model);\n    }\n    let keys = Object.keys(rows[0]);\n    let cache = {};\n    let mainCache = {};\n    cache[this.Model.name] = mainCache;\n    let columns = keys.filter(k => k[0] !== '$');\n    let columnsObject = columns.reduce((columns, k) => {\n      columns[k] = null;\n      return columns;\n    }, {});\n    let joinsObject = keys.filter(k => k[0] === '$').reduce((joinsObject, k) => {\n      let mid = k.indexOf('$', 1);\n      let name = k.substring(1, mid);\n      let field = k.substring(mid + 1);\n      let relationship = this.Model.relationship(name);\n      joinsObject[name] = joinsObject[name] || {};\n      let rModel = relationship.getModel();\n      joinsObject[name].Model = rModel;\n      cache[rModel.name] = {};\n      joinsObject[name].name = name;\n      joinsObject[name].key = k;\n      joinsObject[name].multiple = relationship.immediateMultiple();\n      joinsObject[name].columns = joinsObject[name].columns || [];\n      joinsObject[name].columns.push(field);\n      joinsObject[name].columnsObject = joinsObject[name].columnsObject || {};\n      joinsObject[name].columnsObject[field] = null;\n      joinsObject[name].cachedModel = null;\n      return joinsObject;\n    }, {});\n    let joins = Object.keys(joinsObject).sort((a, b) => a.length > b.length ? 1 : -1).map(k => joinsObject[k]);\n    let models = new ModelArray(this.Model);\n    rows.forEach(row => {\n      let model = mainCache[row.id];\n      if (!model) {\n        model = mainCache[row.id] = new this.Model(columns.reduce((obj, k) => {\n          obj[k] = row[k];\n          return obj;\n        }, columnsObject), true);\n        models.push(model);\n      }\n      joins.forEach(join => {\n        let id = row[`\\$${join.name}\\$id`];\n        let name = join.name;\n        let names = name.split('__');\n        let joinName = names.pop();\n        let parentName = names.join('__');\n        let parentModel = parentName ? joinsObject[parentName].cachedModel : model;\n        if (join.multiple) {\n          parentModel && (parentModel.joined(joinName) || parentModel.setJoined(joinName, new ModelArray(join.Model)));\n        }\n        if (!id) {\n          return;\n        }\n        let joinCache = cache[join.Model.name];\n        let joinModel = join.cachedModel = joinCache[id];\n        if (!joinModel) {\n          joinModel = join.cachedModel = joinCache[id] = new join.Model(join.columns.reduce((obj, k) => {\n            obj[k] = row[`\\$${join.name}\\$${k}`];\n            return obj;\n          }, join.columnsObject), true);\n        }\n        if (join.multiple) {\n          let modelArray = parentModel.joined(joinName);\n          !modelArray.has(joinModel) && modelArray.push(joinModel);\n        } else {\n          parentModel.joined(joinName) || parentModel.setJoined(joinName, joinModel);\n        }\n      });\n    });\n    return models;\n  }\n\n  /**\n  * Collapses linked list of queries into an array (for .reduce, .map etc)\n  * @return {Array}\n  * @private\n  */\n  __collapse__() {\n    let composerArray = [];\n    let composer = this;\n    while (composer) {\n      composerArray.unshift(composer);\n      composer = composer._parent;\n    }\n    return composerArray;\n  }\n\n  /**\n  * Removes last limit command from a collapsed array of composer commands\n  * @param {Array} [composerArray] Array of composer commands\n  * @return {Array}\n  * @private\n  */\n  __removeLastLimitCommand__(composerArray) {\n    let found = composerArray.map(c => c._command && c._command.type).lastIndexOf('limit');\n    found !== -1 && composerArray.splice(found, 1);\n    return composerArray;\n  }\n\n  /**\n  * Gets last limit command from a collapsed array of composer commands\n  * @param {Array} [composerArray] Array of composer commands\n  * @return {Array}\n  * @private\n  */\n  __getLastLimitCommand__(composerArray) {\n    let found = composerArray.map(c => c._command && c._command.type).lastIndexOf('limit');\n    return found >= 0 ? composerArray.splice(found, 1)[0] : null;\n  }\n\n  /**\n  * Determines whether this composer query represents a grouped query or not\n  * @return {Boolean}\n  * @private\n  */\n  __isGrouped__() {\n    return this.__collapse__().filter(c => c._command && c._command.type === 'groupBy').length > 0;\n  }\n\n  /**\n  * Reduces an array of composer queries to a single query information object\n  * @param {Array} [composerArray]\n  * @return {Object} Looks like {commands: [], joins: []}\n  * @private\n  */\n  __reduceToQueryInformation__(composerArray) {\n    let joins = {};\n    let commands = composerArray.reduce((p, c) => {\n      let composerCommand = c._command || {\n        type: 'where',\n        data: {\n          comparisons: []\n        }\n      };\n      if (composerCommand.type === 'join') {\n        let curJoinName = composerCommand.data.name;\n        let curJoinData = composerCommand.data.joinData;\n        joins[curJoinName] = curJoinData;\n        Object.keys(joins).filter(joinName => joinName !== curJoinName).forEach(joinName => {\n          if (curJoinName.indexOf(joinName) === 0) {\n            joins[curJoinName] = joins[joinName].concat(curJoinData.slice(joins[joinName].length));\n            delete joins[joinName];\n          } else if (joinName.indexOf(curJoinName) === 0) {\n            joins[joinName][curJoinData.length - 1] = curJoinData[curJoinData.length - 1];\n            delete joins[curJoinName];\n          }\n        });\n        return p;\n      }\n      let lastCommand = p[p.length - 1];\n      let command = {\n        where: null,\n        limit: null,\n        orderBy: [],\n        groupBy: [],\n        aggregate: []\n      };\n      p.push(command);\n      if (lastCommand && (!lastCommand[composerCommand.type] || lastCommand[composerCommand.type] instanceof Array)) {\n        command = lastCommand;\n        p.pop();\n      }\n      if (command[composerCommand.type] instanceof Array) {\n        command[composerCommand.type].push(Object.keys(composerCommand.data).reduce((p, c) => {\n          return p[c] = composerCommand.data[c], p;\n        }, {}));\n      } else {\n        command[composerCommand.type] = Object.keys(composerCommand.data).reduce((p, c) => {\n          return p[c] = composerCommand.data[c], p;\n        }, {});\n      }\n      return p;\n    }, []);\n    return {\n      commands: commands,\n      joins: joins\n    };\n  }\n\n  /**\n  * Reduces an array of commands from query informtion to a SQL query\n  * @param {Array} [commandArray]\n  * @param {Array} [includeColumns=*] Which columns to include, includes all by default\n  * @return {Object} Looks like {sql: [], params: []}\n  * @private\n  */\n  __reduceCommandsToQuery__(commandArray, includeColumns) {\n    let lastAggregate = null;\n    return commandArray.reduce((prev, command, i) => {\n      if (command.aggregate.length && command.groupBy.length) {\n        lastAggregate = command.aggregate;\n      }\n      let table = `t${i}`;\n      let multiFilter = this.db.adapter.createMultiFilter(table, command.where ? command.where.comparisons : []);\n      let params = this.db.adapter.getParamsFromMultiFilter(multiFilter);\n      let joins = null;\n      let columns = includeColumns || lastAggregate || this.Model.columnNames();\n      columns = columns.map(c => typeof c !== 'string' ? c : {\n        columnNames: [c],\n        alias: c,\n        transformation: v => v\n      }).map(c => Object.keys(c).reduce((p, k) => {\n        return p[k] = c[k], p;\n      }, {}));\n      !command.groupBy.length && columns.forEach(c => {\n        c.transformation = v => v;\n        c.columnNames = [c.alias];\n      });\n      return {\n        sql: this.db.adapter.generateSelectQuery(prev.sql || {\n          table: this.Model.table()\n        }, table, columns, multiFilter, joins, command.groupBy, command.orderBy, command.limit, prev.params.length),\n        params: prev.params.concat(params)\n      };\n    }, {\n      sql: null,\n      params: []\n    });\n  }\n\n  /**\n  * Retrieve all joined column data for a given join\n  * @param {string} joinName The name of the join relationship\n  * @private\n  */\n  __joinedColumns__(joinName) {\n    let relationship = this.Model.relationships().findExplicit(joinName);\n    return relationship.getModel().columnNames().map(columnName => {\n      return {\n        name: joinName,\n        table: relationship.getModel().table(),\n        columnNames: [columnName],\n        alias: `\\$${joinName}\\$${columnName}`,\n        transformation: v => v\n      };\n    });\n  }\n\n  /**\n  * Generate a SQL query and its associated parameters from the current composer instance\n  * @param {Array} [includeColumns=*] Which columns to include, includes all by default\n  * @param {boolean} [disableJoins=false] Disable joins if you just want a subset of data\n  * @return {Object} Has \"params\" and \"sql\" properties.\n  * @private\n  */\n  __generateQuery__(includeColumns, disableJoins) {\n    disableJoins = disableJoins || this.__isGrouped__();\n    let queryInfo = this.__reduceToQueryInformation__(this.__collapse__());\n    let query = this.__reduceCommandsToQuery__(queryInfo.commands, includeColumns);\n    return disableJoins ? query : this.__addJoinsToQuery__(query, queryInfo, includeColumns);\n  }\n\n  /**\n  * Generate a SQL count query\n  * @param {boolean} [useLimit=false] Generates COUNT using limit command as well\n  * @return {Object} Has \"params\" and \"sql\" properties.\n  * @private\n  */\n  __generateCountQuery__(useLimit) {\n    let collapsed = this.__collapse__();\n    collapsed = useLimit ? collapsed : this.__removeLastLimitCommand__(collapsed);\n    let queryInfo = this.__reduceToQueryInformation__(collapsed);\n    let query = this.__reduceCommandsToQuery__(queryInfo.commands);\n    query.sql = this.db.adapter.generateCountQuery(query.sql, 'c');\n    return query;\n  }\n\n  /**\n  * Add Joins to a query from queryInfo\n  * @param {Object} query Must be format {sql: '', params: []}\n  * @param {Object} queryInfo Must be format {commands: [], joins: []}\n  * @param {Array} [includeColumns=*] Which columns to include, includes all by default\n  * @return {Object} Has \"params\" and \"sql\" properties.\n  * @private\n  */\n  __addJoinsToQuery__(query, queryInfo, includeColumns) {\n    let columns = includeColumns || this.Model.columnNames();\n    let joins = queryInfo.joins;\n    Object.keys(joins).forEach(joinName => {\n      joins[joinName].forEach(j => {\n        columns = columns.concat(this.__joinedColumns__(j.joinAlias));\n      });\n    });\n    joins = Object.keys(joins).map(k => joins[k]);\n    let params = query.params.slice();\n    joins.forEach(join => {\n      join.forEach(j => {\n        params = params.concat(this.db.adapter.getParamsFromMultiFilter(j.multiFilter));\n      });\n    });\n\n    // Set join OrderBys... in reverse order\n    let orderBy = queryInfo.commands.reduce((arr, command) => {\n      command.orderBy && (arr = command.orderBy.concat(arr));\n      return arr;\n    }, []);\n\n    // When doing joins, we count paramOffset as the last where parameter length\n    // Because we add in a bunch of parameters at the end.\n\n    return {\n      sql: this.db.adapter.generateSelectQuery(query.sql, 'j', columns, null, joins, null, orderBy, null, query.params.length),\n      params: params\n    };\n  }\n\n  /**\n  * When using Composer#where, format all provided comparisons\n  * @param {Object} comparisons Comparisons object. {age__lte: 27}, for example.\n  * @param {Carthage.Model} Model the model to use as the basis for comparison. Default to current model.\n  * @return {Array}\n  * @private\n  */\n  __parseComparisons__(comparisons, Model) {\n    Model = Model || this.Model;\n    let comparators = this.db.adapter.comparators;\n    let columnLookup = Model.columnLookup();\n    return Object.keys(comparisons).map(comparison => {\n      let column = comparison.split('__');\n      let rel = null;\n      let joinName;\n      let comparator = column.pop();\n      if (!comparators[comparator]) {\n        column.push(comparator);\n        comparator = 'is';\n      }\n      if (column.length > 1) {\n        joinName = column.slice(0, column.length - 1).join('__');\n        rel = Model.relationship(joinName);\n        column = column.slice(column.length - 1);\n      }\n      let table = null;\n      let joined = false;\n      let joins = null;\n      if (rel) {\n        // if it's not found, return null...\n        if (!rel.getModel().hasColumn(column[0])) {\n          return null;\n        }\n        table = rel.getModel().table();\n        joined = true;\n        joins = rel.joins('w');\n      }\n      let columnName = column[0];\n\n      // block out bad column names\n      if (!rel && !Model.hasColumn(columnName)) {\n        return null;\n      }\n      return {\n        table: table,\n        columnName: columnName,\n        comparator: comparator,\n        value: comparisons[comparison],\n        joined: joined,\n        joins: joins\n      };\n    }).filter(v => {\n      return !!v;\n    });\n  }\n  __filterHidden__(Model, comparisonsArray) {\n    comparisonsArray = (comparisonsArray || []).filter(c => c);\n    let comparators = this.db.adapter.comparators;\n    return comparisonsArray.map(comparisons => {\n      Object.keys(comparisons).forEach(comparison => {\n        let cModel = Model;\n        let column = comparison.split('__');\n        let comparator = column.pop();\n        !comparators[comparator] && column.push(comparator);\n        let field = column.pop();\n        let relName = column.join('__');\n        if (relName) {\n          let rel = cModel.relationship(relName);\n          if (!rel) {\n            return;\n          }\n          cModel = rel.getModel();\n        }\n        if (cModel.isHidden(field)) {\n          delete comparisons[comparison];\n        }\n      });\n      if (Object.keys(comparisons).length === 0) {\n        return null;\n      }\n      return comparisons;\n    }).filter(comparisons => comparisons);\n  }\n\n  /**\n  * Add comparisons to SQL WHERE clause. Does not allow filtering if Model.hides() has been called.\n  * @param {Object} comparisons Comparisons object. {age__lte: 27}, for example.\n  * @return {Carthage.Composer} new Composer instance\n  */\n  safeWhere(comparisonsArray) {\n    if (!(comparisonsArray instanceof Array)) {\n      comparisonsArray = [].slice.call(arguments);\n    }\n    return this.where(this.__filterHidden__(this.Model, comparisonsArray));\n  }\n\n  /**\n  * Join in a relationship. Filters out hidden fields from comparisons.\n  * @param {string} joinName The name of the joined relationship\n  * @param {array} comparisonsArray comparisons to perform on this join (can be overloaded)\n  */\n  safeJoin(joinName, comparisonsArray) {\n    if (!(comparisonsArray instanceof Array)) {\n      comparisonsArray = [].slice.call(arguments, 1);\n    }\n    let relationship = this.Model.relationship(joinName);\n    if (!relationship) {\n      return this;\n    }\n    return this.join(joinName, this.__filterHidden__(relationship.getModel(), comparisonsArray));\n  }\n\n  /**\n  * Add comparisons to SQL WHERE clause.\n  * @param {Object} comparisons Comparisons object. {age__lte: 27}, for example.\n  * @return {Carthage.Composer} new Composer instance\n  */\n  where(comparisonsArray) {\n    if (!(comparisonsArray instanceof Array)) {\n      comparisonsArray = [].slice.call(arguments);\n    }\n    comparisonsArray = comparisonsArray.map(comparisons => {\n      return Object.keys(comparisons).reduce((p, c) => {\n        return p[c] = comparisons[c], p;\n      }, {});\n    });\n    let order = null;\n    let offset = null;\n    let count = null;\n    comparisonsArray.forEach(comparisons => {\n      if ('__order' in comparisons) {\n        order = comparisons.__order.split(' ');\n        delete comparisons.__order;\n      }\n      if ('__offset' in comparisons || '__count' in comparisons) {\n        offset = comparisons.__offset;\n        count = comparisons.__count;\n        delete comparisons.__offset;\n        delete comparisons.__count;\n      }\n    });\n    if (order || offset || count) {\n      let composer = this;\n      order && (composer = composer.orderBy(order[0], order[1]));\n      (offset || count) && (composer = composer.limit(offset || 0, count || 0));\n      return composer.where(comparisonsArray);\n    }\n    this._command = {\n      type: 'where',\n      data: {\n        comparisons: comparisonsArray.map(comparisons => this.__parseComparisons__(comparisons)).filter(f => f.length)\n      }\n    };\n    return new Composer(this.Model, this);\n  }\n\n  /**\n  * Order by field belonging to the current Composer instance's model.\n  * @param {string} field Field to order by\n  * @param {string} direction Must be 'ASC' or 'DESC'\n  * @return {Carthage.Composer} new Composer instance\n  */\n  orderBy(field, direction) {\n    let transformation;\n    let fields = [];\n    if (typeof field === 'function') {\n      fields = utilities.getFunctionParameters(field);\n      transformation = field;\n    } else {\n      fields = [field];\n      transformation = v => `${v}`;\n    }\n    fields.forEach(field => {\n      if (!this.Model.hasColumn(field)) {\n        throw new Error(`Cannot order by ${field}, it does not belong to ${this.Model.name}`);\n      }\n    });\n    this._command = {\n      type: 'orderBy',\n      data: {\n        columnNames: fields,\n        transformation: transformation,\n        direction: {\n          'asc': 'ASC',\n          'desc': 'DESC'\n        }[(direction + '').toLowerCase()] || 'ASC'\n      }\n    };\n    return new Composer(this.Model, this);\n  }\n\n  /**\n  * Limit to an offset and count\n  * @param {number} offset The offset at which to set the limit. If this is the only argument provided, it will be the count instead.\n  * @param {number} count The number of results to be returned. Can be omitted, and if omitted, first argument is used for count.\n  * @return {Carthage.Composer} new Composer instance\n  */\n  limit(offset, count) {\n    if (this._command) {\n      return new Composer(this.Model, this).limit(offset, count);\n    }\n    if (count === undefined) {\n      count = offset;\n      offset = 0;\n    }\n    count = parseInt(count);\n    offset = parseInt(offset);\n    this._command = {\n      type: 'limit',\n      data: {\n        count: count,\n        offset: offset\n      }\n    };\n    return new Composer(this.Model, this);\n  }\n\n  /**\n  * Join in a relationship.\n  * @param {string} joinName The name of the joined relationship\n  * @param {array} comparisonsArray comparisons to perform on this join (can be overloaded)\n  */\n  join(joinName, comparisonsArray, orderBy, count, offset) {\n    // FIXME: validate orderBy\n    orderBy = orderBy || '';\n    count = Math.max(0, count | 0);\n    offset = Math.max(0, offset | 0);\n    if (!(comparisonsArray instanceof Array)) {\n      comparisonsArray = [].slice.call(arguments, 1);\n    }\n    let relationship = this.Model.relationships().findExplicit(joinName);\n    if (!relationship) {\n      throw new Error(`Model ${this.Model.name} does not have relationship \"${joinName}\".`);\n    }\n    let composer = this;\n    while (composer) {\n      if (composer._command && composer._command.type === 'join' && composer._command.data.name === joinName) {\n        return this;\n      }\n      composer = composer._parent;\n    }\n    let joinData = relationship.joins();\n    joinData[joinData.length - 1].joinAlias = joinName;\n    joinData[joinData.length - 1].prevAlias = joinName.split('__').slice(0, -1).join('__');\n    joinData[joinData.length - 1].multiFilter = this.db.adapter.createMultiFilter(joinName, comparisonsArray.map(comparisons => this.__parseComparisons__(comparisons, relationship.getModel())).filter(f => f.length));\n\n    // FIXME: implement properly\n    joinData[joinData.length - 1].orderBy = orderBy;\n    joinData[joinData.length - 1].offset = offset;\n    joinData[joinData.length - 1].count = count;\n    this._command = {\n      type: 'join',\n      data: {\n        name: joinName,\n        joinData: joinData\n      }\n    };\n    return new Composer(this.Model, this);\n  }\n\n  /**\n  * Groups by a specific field, or a transformation on a field\n  * @param {String} column The column to group by\n  */\n  groupBy(column) {\n    let columns;\n    let transformation;\n    if (typeof column === 'function') {\n      columns = utilities.getFunctionParameters(column);\n      transformation = column;\n    } else {\n      columns = [column];\n      transformation = v => `${v}`;\n    }\n    this._command = {\n      type: 'groupBy',\n      data: {\n        columnNames: columns,\n        transformation: transformation\n      }\n    };\n    return new Composer(this.Model, this).aggregate(column);\n  }\n\n  /**\n  * Aggregates a field\n  * @param {String} alias The alias for the new aggregate field\n  * @param {Function} transformation The transformation to apply to create the aggregate\n  */\n  aggregate(alias, transformation) {\n    let columns;\n    if (typeof alias === 'function') {\n      columns = utilities.getFunctionParameters(alias);\n      transformation = alias;\n      alias = columns.join('___');\n    } else if (typeof transformation === 'function') {\n      columns = utilities.getFunctionParameters(transformation);\n    } else {\n      columns = [alias];\n      transformation = v => v;\n    }\n    this._command = {\n      type: 'aggregate',\n      data: {\n        alias: alias,\n        columnNames: columns,\n        transformation: transformation\n      }\n    };\n    return new Composer(this.Model, this);\n  }\n\n  /**\n  * Counts the results in the query\n  * @param {function} callback Supplied with an error and the integer value of the count\n  */\n  count(callback) {\n    let countQuery = this.__generateCountQuery__(true);\n    this.db.query(countQuery.sql, countQuery.params, (err, result) => {\n      callback(err, ((result && result.rows || [])[0] || {}).__total__ || 0);\n    });\n  }\n\n  /**\n  * Execute the query you've been composing.\n  * @param {function({Error}, {Carthage.ModelArray})} callback The method to execute when the query is complete\n  */\n  end(callback) {\n    let query = this.__generateQuery__();\n    let countQuery = this.__generateCountQuery__();\n    let grouped = this.__isGrouped__();\n    let limitCommand = this.__getLastLimitCommand__(this.__collapse__());\n    let offset = limitCommand ? limitCommand._command.data.offset : 0;\n    let total = 0;\n    this.db.query(countQuery.sql, countQuery.params, (err, result) => {\n      let total = ((result && result.rows || [])[0] || {}).__total__ || 0;\n      if (!total) {\n        let models = this.__parseModelsFromRows__([], grouped);\n        models.setMeta({\n          offset: offset,\n          total: total\n        });\n        return callback.call(this, err, models);\n      }\n      this.db.query(query.sql, query.params, (err, result) => {\n        let rows = result ? (result.rows || []).slice() : [];\n        let models = this.__parseModelsFromRows__(rows, grouped);\n        models.setMeta({\n          offset: offset,\n          total: total\n        });\n        callback.call(this, err, models);\n      });\n    });\n  }\n\n  /**\n  * Shortcut for .limit(1).end(callback) that only returns a model object or error if not found\n  * @param {Function} callback Callback to execute, provides an error and model parameter\n  */\n  first(callback) {\n    return this.limit(1).end((err, models) => {\n      if (!err && !models.length) {\n        err = new Error(`No records for ${this.Model.name} found in your query`);\n      }\n      callback(err, models[0]);\n    });\n  }\n\n  /**\n  * Execute query as an update query, changed all fields specified.\n  * @param {Object} fields The object containing columns (keys) and associated values you'd like to update\n  * @param {function({Error}, {Carthage.ModelArray})} callback The callback for the update query\n  */\n  update(fields, callback) {\n    if (this.__isGrouped__()) {\n      throw new Error('Cannot update grouped queries');\n    }\n    let query = this.__generateQuery__(['id'], true);\n    let columns = Object.keys(fields);\n    let params = columns.map(c => fields[c]);\n    let columnNames = columns.filter((v, i) => typeof params[i] !== 'function');\n    let columnFunctions = columns.map((v, i) => [v, params[i]]).filter((v, i) => typeof params[i] === 'function');\n    params = params.filter(v => typeof v !== 'function');\n    query.sql = this.db.adapter.generateUpdateAllQuery(this.Model.table(), 'id', columnNames, columnFunctions, query.params.length, query.sql);\n    query.params = query.params.concat(params);\n    return this.db.query(query.sql, query.params, (err, result) => {\n      let rows = result ? (result.rows || []).slice() : [];\n      if (err) {\n        let models = this.__parseModelsFromRows__(rows);\n        return callback.call(this, err, models);\n      }\n      let ids = result.rows.map(row => row.id);\n\n      /* Grab all items with ids, sorted by order */\n      /* Only need to grab joins and order */\n\n      let composerArray = this.__collapse__().filter(composer => composer._command).filter(composer => composer._command.type === 'orderBy' || composer._command.type === 'join');\n\n      // Add in id filter\n      composerArray.unshift(new Composer(this.Model).where({\n        id__in: ids\n      })._parent);\n      let queryInfo = this.__reduceToQueryInformation__(composerArray);\n      let query = this.__reduceCommandsToQuery__(queryInfo.commands);\n      query = this.__addJoinsToQuery__(query, queryInfo);\n      return this.db.query(query.sql, query.params, (err, result) => {\n        let rows = result ? (result.rows || []).slice() : [];\n        let models = this.__parseModelsFromRows__(rows);\n        callback.call(this, err, models);\n      });\n    });\n  }\n}\nmodule.exports = Composer;","map":{"version":3,"names":["ItemArray","require","ModelArray","utilities","Composer","constructor","Model","parent","db","prototype","_parent","_command","__parseModelsFromRows__","rows","grouped","from","length","keys","Object","cache","mainCache","name","columns","filter","k","columnsObject","reduce","joinsObject","mid","indexOf","substring","field","relationship","rModel","getModel","key","multiple","immediateMultiple","push","cachedModel","joins","sort","a","b","map","models","forEach","row","model","id","obj","join","names","split","joinName","pop","parentName","parentModel","joined","setJoined","joinCache","joinModel","modelArray","has","__collapse__","composerArray","composer","unshift","__removeLastLimitCommand__","found","c","type","lastIndexOf","splice","__getLastLimitCommand__","__isGrouped__","__reduceToQueryInformation__","commands","p","composerCommand","data","comparisons","curJoinName","curJoinData","joinData","concat","slice","lastCommand","command","where","limit","orderBy","groupBy","aggregate","Array","__reduceCommandsToQuery__","commandArray","includeColumns","lastAggregate","prev","i","table","multiFilter","adapter","createMultiFilter","params","getParamsFromMultiFilter","columnNames","alias","transformation","v","sql","generateSelectQuery","__joinedColumns__","relationships","findExplicit","columnName","__generateQuery__","disableJoins","queryInfo","query","__addJoinsToQuery__","__generateCountQuery__","useLimit","collapsed","generateCountQuery","j","joinAlias","arr","__parseComparisons__","comparators","columnLookup","comparison","column","rel","comparator","hasColumn","value","__filterHidden__","comparisonsArray","cModel","relName","isHidden","safeWhere","call","arguments","safeJoin","order","offset","count","__order","__offset","__count","f","direction","fields","getFunctionParameters","Error","toLowerCase","undefined","parseInt","Math","max","prevAlias","callback","countQuery","err","result","__total__","end","limitCommand","total","setMeta","first","update","columnFunctions","generateUpdateAllQuery","ids","id__in","module","exports"],"sources":["/Users/apps/node_modules/carthage/core/required/composer.js"],"sourcesContent":["'use strict';\n\nconst ItemArray = require('./item_array.js');\nconst ModelArray = require('./model_array.js');\n\nconst utilities = require('./utilities.js');\n\n/**\n* The query composer (ORM)\n* @class\n*/\nclass Composer {\n\n  /**\n  * Created by Model#query, used for composing SQL queries based on Models\n  * @param {Carthage.Model} Model The model class the composer is querying from\n  * @param {Carthage.Composer} [parent=null] The composer's parent (another composer instance)\n  */\n  constructor(Model, parent) {\n\n    this.db = Model.prototype.db;\n    this.Model = Model;\n\n    this._parent = parent || null;\n    this._command = null;\n\n  }\n\n  /**\n  * Given rows with repeated data (due to joining in multiple children), return only parent models (but include references to their children)\n  * @param {Array} rows Rows from sql result\n  * @param {Boolean} grouped Are these models grouped, if so, different procedure\n  * @return {Carthage.ModelArray}\n  * @private\n  */\n  __parseModelsFromRows__(rows, grouped) {\n\n    if (grouped) {\n      return ItemArray.from(rows);\n    }\n\n    if (!rows.length) {\n      return new ModelArray(this.Model);\n    }\n\n    let keys = Object.keys(rows[0]);\n    let cache = {};\n    let mainCache = {};\n    cache[this.Model.name] = mainCache;\n\n    let columns = keys\n      .filter(k => k[0] !== '$');\n\n    let columnsObject = columns\n      .reduce((columns, k) => {\n\n        columns[k] = null;\n        return columns;\n\n      }, {});\n\n    let joinsObject = keys\n      .filter(k => k[0] === '$')\n      .reduce((joinsObject, k) => {\n\n        let mid = k.indexOf('$', 1);\n        let name = k.substring(1, mid)\n        let field = k.substring(mid + 1);\n        let relationship = this.Model.relationship(name);\n\n        joinsObject[name] = joinsObject[name] || {};\n\n        let rModel = relationship.getModel()\n        joinsObject[name].Model = rModel;\n        cache[rModel.name] = {};\n\n        joinsObject[name].name = name;\n        joinsObject[name].key = k;\n        joinsObject[name].multiple = relationship.immediateMultiple();\n\n        joinsObject[name].columns = joinsObject[name].columns || [];\n        joinsObject[name].columns.push(field);\n\n        joinsObject[name].columnsObject = joinsObject[name].columnsObject || {};\n        joinsObject[name].columnsObject[field] = null;\n\n        joinsObject[name].cachedModel = null;\n\n        return joinsObject;\n\n      }, {});\n\n    let joins = Object\n      .keys(joinsObject)\n      .sort((a, b) => a.length > b.length ? 1 : -1)\n      .map(k => joinsObject[k]);\n\n    let models = new ModelArray(this.Model);\n\n    rows.forEach(row => {\n\n      let model = mainCache[row.id];\n\n      if (!model) {\n\n        model = mainCache[row.id] = new this.Model(columns.reduce((obj, k) => {\n          obj[k] = row[k];\n          return obj;\n        }, columnsObject), true);\n\n        models.push(model);\n\n      }\n\n      joins.forEach(join => {\n\n        let id = row[`\\$${join.name}\\$id`];\n\n        let name = join.name;\n        let names = name.split('__');\n        let joinName = names.pop();\n        let parentName = names.join('__');\n\n        let parentModel = parentName ? joinsObject[parentName].cachedModel : model;\n\n        if (join.multiple) {\n          parentModel && (parentModel.joined(joinName) || parentModel.setJoined(joinName, new ModelArray(join.Model)));\n        }\n\n        if (!id) {\n          return;\n        }\n\n        let joinCache = cache[join.Model.name];\n        let joinModel = join.cachedModel = joinCache[id];\n\n        if (!joinModel) {\n          joinModel = join.cachedModel = joinCache[id] = new join.Model(join.columns.reduce((obj, k) => {\n            obj[k] = row[`\\$${join.name}\\$${k}`];\n            return obj;\n          }, join.columnsObject), true)\n        }\n\n\n        if (join.multiple) {\n          let modelArray = parentModel.joined(joinName);\n          !modelArray.has(joinModel) && modelArray.push(joinModel);\n        } else {\n          parentModel.joined(joinName) || parentModel.setJoined(joinName, joinModel);\n        }\n\n      });\n\n    });\n\n    return models;\n\n  }\n\n  /**\n  * Collapses linked list of queries into an array (for .reduce, .map etc)\n  * @return {Array}\n  * @private\n  */\n  __collapse__() {\n\n    let composerArray = [];\n    let composer = this;\n\n    while (composer) {\n      composerArray.unshift(composer);\n      composer = composer._parent;\n    }\n\n    return composerArray;\n\n  }\n\n  /**\n  * Removes last limit command from a collapsed array of composer commands\n  * @param {Array} [composerArray] Array of composer commands\n  * @return {Array}\n  * @private\n  */\n  __removeLastLimitCommand__(composerArray) {\n\n    let found = composerArray.map(c => c._command && c._command.type).lastIndexOf('limit');\n    (found !== -1) && composerArray.splice(found, 1);\n    return composerArray;\n\n  }\n\n  /**\n  * Gets last limit command from a collapsed array of composer commands\n  * @param {Array} [composerArray] Array of composer commands\n  * @return {Array}\n  * @private\n  */\n  __getLastLimitCommand__(composerArray) {\n\n    let found = composerArray.map(c => c._command && c._command.type).lastIndexOf('limit');\n    return found >= 0 ? composerArray.splice(found, 1)[0] : null;\n\n  }\n\n  /**\n  * Determines whether this composer query represents a grouped query or not\n  * @return {Boolean}\n  * @private\n  */\n  __isGrouped__() {\n    return this.__collapse__().filter(c => c._command && c._command.type === 'groupBy').length > 0;\n  }\n\n  /**\n  * Reduces an array of composer queries to a single query information object\n  * @param {Array} [composerArray]\n  * @return {Object} Looks like {commands: [], joins: []}\n  * @private\n  */\n  __reduceToQueryInformation__(composerArray) {\n\n    let joins = {};\n\n    let commands = composerArray.reduce((p, c) => {\n\n      let composerCommand = c._command || {type: 'where', data: {comparisons: []}};\n\n      if (composerCommand.type === 'join') {\n\n        let curJoinName = composerCommand.data.name;\n        let curJoinData = composerCommand.data.joinData;\n        joins[curJoinName] = curJoinData;\n        Object.keys(joins)\n          .filter(joinName => joinName !== curJoinName)\n          .forEach(joinName => {\n\n            if (curJoinName.indexOf(joinName) === 0) {\n              joins[curJoinName] = joins[joinName].concat(curJoinData.slice(joins[joinName].length));\n              delete joins[joinName];\n            } else if (joinName.indexOf(curJoinName) === 0) {\n              joins[joinName][curJoinData.length - 1] = curJoinData[curJoinData.length - 1];\n              delete joins[curJoinName];\n            }\n\n          });\n\n        return p;\n\n      }\n\n      let lastCommand = p[p.length - 1];\n      let command = {\n        where: null,\n        limit: null,\n        orderBy: [],\n        groupBy: [],\n        aggregate: []\n      };\n      p.push(command);\n\n      if (\n        lastCommand && (\n          !lastCommand[composerCommand.type] ||\n          lastCommand[composerCommand.type] instanceof Array\n        )\n      ) {\n\n        command = lastCommand;\n        p.pop();\n\n      }\n\n      if (command[composerCommand.type] instanceof Array) {\n\n        command[composerCommand.type].push(\n          Object.keys(composerCommand.data).reduce((p, c) => {\n            return (p[c] = composerCommand.data[c], p);\n          }, {})\n        );\n\n      } else {\n\n        command[composerCommand.type] = Object.keys(composerCommand.data).reduce((p, c) => {\n          return (p[c] = composerCommand.data[c], p);\n        }, {});\n\n      }\n\n      return p;\n\n    }, []);\n\n    return {\n      commands: commands,\n      joins: joins\n    }\n\n  }\n\n  /**\n  * Reduces an array of commands from query informtion to a SQL query\n  * @param {Array} [commandArray]\n  * @param {Array} [includeColumns=*] Which columns to include, includes all by default\n  * @return {Object} Looks like {sql: [], params: []}\n  * @private\n  */\n  __reduceCommandsToQuery__(commandArray, includeColumns) {\n\n    let lastAggregate = null;\n\n    return commandArray.reduce((prev, command, i) => {\n\n      if (command.aggregate.length && command.groupBy.length) {\n        lastAggregate = command.aggregate;\n      }\n\n      let table = `t${i}`;\n\n      let multiFilter = this.db.adapter.createMultiFilter(table, command.where ? command.where.comparisons : []);\n      let params = this.db.adapter.getParamsFromMultiFilter(multiFilter);\n\n      let joins = null;\n      let columns = includeColumns || lastAggregate || this.Model.columnNames();\n\n      columns = columns\n        .map(c => typeof c !== 'string' ? c : {columnNames: [c], alias: c, transformation: v => v})\n        .map(c => Object.keys(c).reduce((p, k) => { return (p[k] = c[k], p); }, {}));\n\n      !command.groupBy.length && columns.forEach(c => {\n        c.transformation = v => v;\n        c.columnNames = [c.alias];\n      });\n\n      return {\n        sql: this.db.adapter.generateSelectQuery(\n          prev.sql || {table: this.Model.table()},\n          table,\n          columns,\n          multiFilter,\n          joins,\n          command.groupBy,\n          command.orderBy,\n          command.limit,\n          prev.params.length\n        ),\n        params: prev.params.concat(params)\n      }\n\n    }, {sql: null, params: []});\n\n  }\n\n  /**\n  * Retrieve all joined column data for a given join\n  * @param {string} joinName The name of the join relationship\n  * @private\n  */\n  __joinedColumns__(joinName) {\n    let relationship = this.Model.relationships().findExplicit(joinName);\n    return relationship.getModel().columnNames().map(columnName => {\n      return {\n        name: joinName,\n        table: relationship.getModel().table(),\n        columnNames: [columnName],\n        alias: `\\$${joinName}\\$${columnName}`,\n        transformation: v => v\n      };\n    });\n  }\n\n  /**\n  * Generate a SQL query and its associated parameters from the current composer instance\n  * @param {Array} [includeColumns=*] Which columns to include, includes all by default\n  * @param {boolean} [disableJoins=false] Disable joins if you just want a subset of data\n  * @return {Object} Has \"params\" and \"sql\" properties.\n  * @private\n  */\n  __generateQuery__(includeColumns, disableJoins) {\n\n    disableJoins = disableJoins || this.__isGrouped__();\n\n    let queryInfo = this.__reduceToQueryInformation__(this.__collapse__());\n    let query = this.__reduceCommandsToQuery__(queryInfo.commands, includeColumns);\n\n    return disableJoins ? query : this.__addJoinsToQuery__(\n      query,\n      queryInfo,\n      includeColumns\n    );\n\n  }\n\n  /**\n  * Generate a SQL count query\n  * @param {boolean} [useLimit=false] Generates COUNT using limit command as well\n  * @return {Object} Has \"params\" and \"sql\" properties.\n  * @private\n  */\n  __generateCountQuery__(useLimit) {\n\n    let collapsed = this.__collapse__();\n    collapsed = useLimit ? collapsed : this.__removeLastLimitCommand__(collapsed);\n    let queryInfo = this.__reduceToQueryInformation__(collapsed);\n    let query = this.__reduceCommandsToQuery__(queryInfo.commands);\n    query.sql = this.db.adapter.generateCountQuery(query.sql, 'c');\n    return query;\n\n  }\n\n  /**\n  * Add Joins to a query from queryInfo\n  * @param {Object} query Must be format {sql: '', params: []}\n  * @param {Object} queryInfo Must be format {commands: [], joins: []}\n  * @param {Array} [includeColumns=*] Which columns to include, includes all by default\n  * @return {Object} Has \"params\" and \"sql\" properties.\n  * @private\n  */\n  __addJoinsToQuery__(query, queryInfo, includeColumns) {\n\n    let columns = includeColumns || this.Model.columnNames();\n\n    let joins = queryInfo.joins;\n\n    Object.keys(joins).forEach(joinName => {\n      joins[joinName].forEach(j => {\n        columns = columns.concat(this.__joinedColumns__(j.joinAlias));\n      });\n    });\n\n    joins = Object.keys(joins).map(k => joins[k]);\n    let params = query.params.slice();\n\n    joins.forEach(join => {\n\n      join.forEach(j => {\n        params = params.concat(this.db.adapter.getParamsFromMultiFilter(j.multiFilter));\n      });\n\n    });\n\n    // Set join OrderBys... in reverse order\n    let orderBy = queryInfo.commands.reduce((arr, command) => {\n      command.orderBy && (arr = command.orderBy.concat(arr));\n      return arr;\n    }, []);\n\n    // When doing joins, we count paramOffset as the last where parameter length\n    // Because we add in a bunch of parameters at the end.\n\n    return {\n      sql: this.db.adapter.generateSelectQuery(\n        query.sql,\n        'j',\n        columns,\n        null,\n        joins,\n        null,\n        orderBy,\n        null,\n        query.params.length\n      ),\n      params: params\n    };\n\n  }\n\n  /**\n  * When using Composer#where, format all provided comparisons\n  * @param {Object} comparisons Comparisons object. {age__lte: 27}, for example.\n  * @param {Carthage.Model} Model the model to use as the basis for comparison. Default to current model.\n  * @return {Array}\n  * @private\n  */\n  __parseComparisons__(comparisons, Model) {\n\n    Model = Model || this.Model;\n\n    let comparators = this.db.adapter.comparators;\n    let columnLookup = Model.columnLookup();\n\n    return Object.keys(comparisons)\n      .map(comparison => {\n\n        let column = comparison.split('__');\n        let rel = null;\n        let joinName;\n\n        let comparator = column.pop();\n        if (!comparators[comparator]) {\n          column.push(comparator);\n          comparator = 'is';\n        }\n\n        if (column.length > 1) {\n          joinName = column.slice(0, column.length - 1).join('__');\n          rel = Model.relationship(joinName);\n          column = column.slice(column.length - 1);\n        }\n\n        let table = null;\n        let joined = false;\n        let joins = null;\n\n        if (rel) {\n\n          // if it's not found, return null...\n          if (!rel.getModel().hasColumn(column[0])) {\n            return null;\n          }\n\n          table = rel.getModel().table();\n          joined = true;\n          joins = rel.joins('w');\n\n        }\n\n        let columnName = column[0];\n\n        // block out bad column names\n        if (!rel && !Model.hasColumn(columnName)) {\n          return null;\n        }\n\n        return {\n          table: table,\n          columnName: columnName,\n          comparator: comparator,\n          value: comparisons[comparison],\n          joined: joined,\n          joins: joins\n        };\n\n      })\n      .filter(v => {\n        return !!v;\n      });\n\n  }\n\n  __filterHidden__(Model, comparisonsArray) {\n\n    comparisonsArray = (comparisonsArray || []).filter(c => c);\n\n    let comparators = this.db.adapter.comparators;\n\n    return comparisonsArray.map(comparisons => {\n\n      Object.keys(comparisons).forEach(comparison => {\n\n        let cModel = Model;\n\n        let column = comparison.split('__');\n        let comparator = column.pop();\n        !comparators[comparator] && column.push(comparator);\n        let field = column.pop();\n        let relName = column.join('__');\n        if (relName) {\n          let rel = cModel.relationship(relName);\n          if (!rel) {\n            return;\n          }\n          cModel = rel.getModel();\n        }\n\n        if (cModel.isHidden(field)) {\n          delete comparisons[comparison];\n        }\n\n      });\n\n      if (Object.keys(comparisons).length === 0) {\n        return null;\n      }\n\n      return comparisons;\n\n    }).filter(comparisons => comparisons);\n\n  }\n\n  /**\n  * Add comparisons to SQL WHERE clause. Does not allow filtering if Model.hides() has been called.\n  * @param {Object} comparisons Comparisons object. {age__lte: 27}, for example.\n  * @return {Carthage.Composer} new Composer instance\n  */\n  safeWhere(comparisonsArray) {\n\n    if (!(comparisonsArray instanceof Array)) {\n      comparisonsArray = [].slice.call(arguments);\n    }\n\n    return this.where(\n      this.__filterHidden__(\n        this.Model,\n        comparisonsArray\n      )\n    );\n\n  }\n\n  /**\n  * Join in a relationship. Filters out hidden fields from comparisons.\n  * @param {string} joinName The name of the joined relationship\n  * @param {array} comparisonsArray comparisons to perform on this join (can be overloaded)\n  */\n  safeJoin(joinName, comparisonsArray) {\n\n    if (!(comparisonsArray instanceof Array)) {\n      comparisonsArray = [].slice.call(arguments, 1);\n    }\n\n    let relationship = this.Model.relationship(joinName);\n    if (!relationship) {\n      return this;\n    }\n\n    return this.join(\n      joinName,\n      this.__filterHidden__(\n        relationship.getModel(),\n        comparisonsArray\n      )\n    );\n\n  }\n\n  /**\n  * Add comparisons to SQL WHERE clause.\n  * @param {Object} comparisons Comparisons object. {age__lte: 27}, for example.\n  * @return {Carthage.Composer} new Composer instance\n  */\n  where(comparisonsArray) {\n\n    if (!(comparisonsArray instanceof Array)) {\n      comparisonsArray = [].slice.call(arguments);\n    }\n\n    comparisonsArray = comparisonsArray.map(comparisons => {\n      return Object.keys(comparisons).reduce((p, c) => { return (p[c] = comparisons[c], p); }, {});\n    });\n\n    let order = null;\n    let offset = null;\n    let count = null;\n\n    comparisonsArray.forEach(comparisons => {\n\n      if ('__order' in comparisons) {\n        order = comparisons.__order.split(' ');\n        delete comparisons.__order;\n      }\n\n      if ('__offset' in comparisons || '__count' in comparisons) {\n        offset = comparisons.__offset;\n        count = comparisons.__count;\n        delete comparisons.__offset;\n        delete comparisons.__count;\n      }\n\n    });\n\n    if (order || offset || count) {\n      let composer = this;\n      order && (composer = composer.orderBy(order[0], order[1]));\n      (offset || count) && (composer = composer.limit(offset || 0, count || 0));\n      return composer.where(comparisonsArray);\n    }\n\n    this._command = {\n      type: 'where',\n      data: {\n        comparisons: comparisonsArray\n        .map(comparisons => this.__parseComparisons__(comparisons))\n        .filter(f => f.length)\n      }\n    };\n\n    return new Composer(this.Model, this);\n\n  }\n\n  /**\n  * Order by field belonging to the current Composer instance's model.\n  * @param {string} field Field to order by\n  * @param {string} direction Must be 'ASC' or 'DESC'\n  * @return {Carthage.Composer} new Composer instance\n  */\n  orderBy(field, direction) {\n\n    let transformation;\n    let fields = [];\n\n    if (typeof field === 'function') {\n      fields = utilities.getFunctionParameters(field);\n      transformation = field;\n    } else {\n      fields = [field];\n      transformation = v => `${v}`;\n    }\n\n    fields.forEach(field => {\n      if (!this.Model.hasColumn(field)) {\n        throw new Error(`Cannot order by ${field}, it does not belong to ${this.Model.name}`);\n      }\n    });\n\n    this._command = {\n      type: 'orderBy',\n      data: {\n        columnNames: fields,\n        transformation: transformation,\n        direction: ({'asc': 'ASC', 'desc': 'DESC'}[(direction + '').toLowerCase()] || 'ASC')\n      }\n    };\n\n    return new Composer(this.Model, this);\n\n  }\n\n  /**\n  * Limit to an offset and count\n  * @param {number} offset The offset at which to set the limit. If this is the only argument provided, it will be the count instead.\n  * @param {number} count The number of results to be returned. Can be omitted, and if omitted, first argument is used for count.\n  * @return {Carthage.Composer} new Composer instance\n  */\n  limit(offset, count) {\n\n    if (this._command) {\n      return new Composer(this.Model, this).limit(offset, count);\n    }\n\n    if (count === undefined) {\n      count = offset;\n      offset = 0;\n    }\n\n    count = parseInt(count);\n    offset = parseInt(offset);\n\n    this._command = {\n      type: 'limit',\n      data: {\n        count: count,\n        offset: offset\n      }\n    };\n\n    return new Composer(this.Model, this);\n\n  }\n\n  /**\n  * Join in a relationship.\n  * @param {string} joinName The name of the joined relationship\n  * @param {array} comparisonsArray comparisons to perform on this join (can be overloaded)\n  */\n  join(joinName, comparisonsArray, orderBy, count, offset) {\n\n    // FIXME: validate orderBy\n    orderBy = orderBy || '';\n    count = Math.max(0, count | 0);\n    offset = Math.max(0, offset | 0);\n\n    if (!(comparisonsArray instanceof Array)) {\n      comparisonsArray = [].slice.call(arguments, 1);\n    }\n\n    let relationship = this.Model.relationships().findExplicit(joinName);\n    if (!relationship) {\n      throw new Error(`Model ${this.Model.name} does not have relationship \"${joinName}\".`);\n    }\n\n    let composer = this;\n    while (composer) {\n      if (composer._command && composer._command.type === 'join' && composer._command.data.name === joinName) {\n        return this;\n      }\n      composer = composer._parent;\n    }\n\n    let joinData = relationship.joins();\n    joinData[joinData.length - 1].joinAlias = joinName;\n    joinData[joinData.length - 1].prevAlias = joinName.split('__').slice(0, -1).join('__');\n    joinData[joinData.length - 1].multiFilter = this.db.adapter.createMultiFilter(\n      joinName,\n      comparisonsArray\n        .map(comparisons => this.__parseComparisons__(comparisons, relationship.getModel()))\n        .filter(f => f.length)\n    );\n\n    // FIXME: implement properly\n    joinData[joinData.length - 1].orderBy = orderBy;\n    joinData[joinData.length - 1].offset = offset;\n    joinData[joinData.length - 1].count = count;\n\n    this._command = {\n      type: 'join',\n      data: {\n        name: joinName,\n        joinData: joinData\n      }\n    };\n\n    return new Composer(this.Model, this);\n\n  }\n\n  /**\n  * Groups by a specific field, or a transformation on a field\n  * @param {String} column The column to group by\n  */\n  groupBy(column) {\n\n    let columns;\n    let transformation;\n\n    if (typeof column === 'function') {\n      columns = utilities.getFunctionParameters(column);\n      transformation = column;\n    } else {\n      columns = [column];\n      transformation = v => `${v}`;\n    }\n\n    this._command = {\n      type: 'groupBy',\n      data: {\n        columnNames: columns,\n        transformation: transformation\n      }\n    };\n\n    return new Composer(this.Model, this).aggregate(column);\n\n  }\n\n  /**\n  * Aggregates a field\n  * @param {String} alias The alias for the new aggregate field\n  * @param {Function} transformation The transformation to apply to create the aggregate\n  */\n  aggregate(alias, transformation) {\n\n    let columns;\n\n    if (typeof alias === 'function') {\n      columns = utilities.getFunctionParameters(alias);\n      transformation = alias;\n      alias = columns.join('___');\n    } else if (typeof transformation === 'function') {\n      columns = utilities.getFunctionParameters(transformation);\n    } else {\n      columns = [alias]\n      transformation = v => v;\n    }\n\n    this._command = {\n      type: 'aggregate',\n      data: {\n        alias: alias,\n        columnNames: columns,\n        transformation: transformation\n      }\n    };\n\n    return new Composer(this.Model, this);\n\n  }\n\n  /**\n  * Counts the results in the query\n  * @param {function} callback Supplied with an error and the integer value of the count\n  */\n  count(callback) {\n\n    let countQuery = this.__generateCountQuery__(true);\n\n    this.db.query(countQuery.sql, countQuery.params, (err, result) => {\n\n      callback(err, (((result && result.rows) || [])[0] || {}).__total__ || 0);\n\n    });\n\n  }\n\n  /**\n  * Execute the query you've been composing.\n  * @param {function({Error}, {Carthage.ModelArray})} callback The method to execute when the query is complete\n  */\n  end(callback) {\n\n    let query = this.__generateQuery__();\n    let countQuery = this.__generateCountQuery__();\n\n    let grouped = this.__isGrouped__();\n\n    let limitCommand = this.__getLastLimitCommand__(this.__collapse__());\n    let offset = limitCommand ? limitCommand._command.data.offset : 0;\n    let total = 0;\n\n    this.db.query(countQuery.sql, countQuery.params, (err, result) => {\n\n      let total = (((result && result.rows) || [])[0] || {}).__total__ || 0;\n\n      if (!total) {\n        let models = this.__parseModelsFromRows__([], grouped);\n        models.setMeta({offset: offset, total: total});\n        return callback.call(this, err, models);\n      }\n\n      this.db.query(query.sql, query.params, (err, result) => {\n\n        let rows = result ? (result.rows || []).slice() : [];\n        let models = this.__parseModelsFromRows__(rows, grouped);\n        models.setMeta({offset: offset, total: total});\n        callback.call(this, err, models);\n\n      });\n\n    });\n\n  }\n\n  /**\n  * Shortcut for .limit(1).end(callback) that only returns a model object or error if not found\n  * @param {Function} callback Callback to execute, provides an error and model parameter\n  */\n  first(callback) {\n\n    return this.limit(1).end((err, models) => {\n\n      if (!err && !models.length) {\n        err = new Error(`No records for ${this.Model.name} found in your query`);\n      }\n\n      callback(err, models[0]);\n\n    });\n\n  }\n\n  /**\n  * Execute query as an update query, changed all fields specified.\n  * @param {Object} fields The object containing columns (keys) and associated values you'd like to update\n  * @param {function({Error}, {Carthage.ModelArray})} callback The callback for the update query\n  */\n  update(fields, callback) {\n\n    if (this.__isGrouped__()) {\n      throw new Error('Cannot update grouped queries');\n    }\n\n    let query = this.__generateQuery__(['id'], true);\n    let columns = Object.keys(fields);\n    let params = columns.map(c => fields[c]);\n\n    let columnNames = columns.filter((v, i) => typeof params[i] !== 'function');\n    let columnFunctions = columns\n      .map((v, i) => [v, params[i]])\n      .filter((v, i) => typeof params[i] === 'function');\n\n    params = params.filter(v => typeof v !== 'function');\n\n    query.sql = this.db.adapter.generateUpdateAllQuery(\n      this.Model.table(),\n      'id',\n      columnNames,\n      columnFunctions,\n      query.params.length,\n      query.sql\n    );\n\n    query.params = query.params.concat(params);\n\n    return this.db.query(query.sql, query.params, (err, result) => {\n\n      let rows = result ? (result.rows || []).slice() : [];\n\n      if (err) {\n        let models = this.__parseModelsFromRows__(rows);\n        return callback.call(this, err, models);\n      }\n\n      let ids = result.rows.map(row => row.id);\n\n      /* Grab all items with ids, sorted by order */\n      /* Only need to grab joins and order */\n\n      let composerArray = this.__collapse__()\n        .filter(composer => composer._command)\n        .filter(composer => composer._command.type === 'orderBy' || composer._command.type === 'join');\n\n      // Add in id filter\n      composerArray.unshift(new Composer(this.Model).where({id__in: ids})._parent);\n\n      let queryInfo = this.__reduceToQueryInformation__(composerArray);\n      let query = this.__reduceCommandsToQuery__(queryInfo.commands);\n      query = this.__addJoinsToQuery__(query, queryInfo);\n\n      return this.db.query(query.sql, query.params, (err, result) => {\n\n        let rows = result ? (result.rows || []).slice() : [];\n        let models = this.__parseModelsFromRows__(rows);\n\n        callback.call(this, err, models);\n\n      });\n\n    });\n\n  }\n\n}\n\nmodule.exports = Composer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}